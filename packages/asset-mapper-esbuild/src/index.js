// @ts-check
//
import path from "path"
import process from "process";
import fsLib from "fs";

const fs = fsLib.promises;

/**
 * @typedef {Object} ManifestData
 * @property {string} asset_path
 * @property {string} file_path
 */

/**
 * @param {{ outputRoot?: string, entrypointRoot?: string, manifestFile?: string }} [options={}] Plugin options.
 * @return {import("esbuild").Plugin}
 */
export default function AssetMapperPlugin(options = {}) {
  if (options == null) options = {};

  let {
    outputRoot,
    entrypointRoot,
    manifestFile
  } = options;

  return {
    name: "asset-mapper-manifest",

    setup(build) {
      build.initialOptions.metafile = true;

      // Lets prefill some loaders, but always use what the user has defined.
      build.initialOptions.loader = {
        ".png": "file",
        ".woff": "file",
        ".woff2": "file",
        ".svg": "file",
        ".webp": "file",
        ".jpeg": "file",
        ".jpg": "file",
        ".gif": "file",
        ".avif": "file",
        ".ttf": "file",
        ".eot": "file",
        ".mp4": "file",
        ...build.initialOptions.loader
      }

      // assume that the user wants to hash their files by default,
      // but don't override any hashing format they may have already set.
      /** @type {Array<"entryNames" | "assetNames" | "chunkNames">} */
      const names = ["entryNames", "assetNames", "chunkNames"]

      names.forEach((str) => {
        if (build.initialOptions[str]) return;

        if (str === "chunkNames") {
          build.initialOptions[str] = "chunks/[name]-[hash]";
          return;
        }

        build.initialOptions[str] = "[dir]/[name]-[hash]";
      });

      build.onEnd(async (result) => {
        if (!result.metafile) {
          console.warn(
            "No metafile found from ESBuild. No manifest generated by AssetMapperManifest."
          );
          return;
        }

        if (!result.metafile.outputs) {
          console.warn(
            "No outputs found. Make sure you are passing entrypoints to ESBuild."
          );
          return;
        }

        const outfileDir = build.initialOptions.outfile
          ? build.initialOptions.outfile
          : null;

        const outdir =
          build.initialOptions.outdir || outfileDir || process.cwd();

  		  if (outputRoot == null) {
  			  outputRoot = path.relative(process.cwd(), outdir)
  			  console.warn(`No {outputRoot} defined. Using: ${outputRoot}`)
  		  }

  		  if (entrypointRoot == null) {
  		    entrypointRoot = process.cwd()
  		    console.warn(`
            No {entrypointRoot} defined. Using: ${entrypointRoot}
            In Rails, typically the {entrypointRoot} is "app/javascript/"
          `)
  		  }

        /** @type Map<string, ManifestData> */
        const manifest = new Map();


        // Let's loop through all the various outputs
        // I feel like this may not be needed with AssetMapper shipping its own file manifest creator.
        for (const hashedPath in result.metafile.outputs) {
          const output = result.metafile.outputs[hashedPath];

          if (!output.entryPoint) {
            continue;
          }

          const entryPoint = output.entryPoint;

					let finalPath = hashedPath


					// Theres probably better ways to do this, but basically if we import an SVG
					// its final location will be: "thing.svg -> thing-[hash].js", this goes back through
					// the outputs and finds the correct SVG.
					// https://github.com/evanw/esbuild/issues/2731
					const loader = build.initialOptions.loader || {}
					const { ext } = path.parse(entryPoint)

					const isExternalFile = loader[ext] === "file"

					if (isExternalFile) {
						for (const key in result.metafile.outputs) {
							const val = result.metafile.outputs[key]
							const inputs = Object.keys(val.inputs)

							if (inputs.length !== 1) continue

							const asset = inputs[0]
							if (asset === entryPoint) {
								finalPath = key
								break
							}
						}
					}


          // Replace the relative paths. We don't need "/public" or "app/javascript"
          manifest.set(
            path.relative(entrypointRoot, entryPoint),
            {
              asset_path: path.relative(outputRoot, finalPath),
              file_path: finalPath
            }
          );

          if (!output.cssBundle) continue;

          const { dir, name } = path.parse(entryPoint);
          const cssBundle = path.join(dir, name + ".css");
          manifest.set(
            path.relative(entrypointRoot, cssBundle),
            {
              asset_path: path.relative(outputRoot, output.cssBundle),
              file_path: output.cssBundle
            }
          );
        }


        if (!manifestFile) {
          manifestFile = path.join(outputRoot, "asset-mapper-manifest.json")
        }

        const manifestFolder = path.dirname(manifestFile);
        await fs.mkdir(manifestFolder, { recursive: true });

        await fs.writeFile(
          manifestFile,
          JSON.stringify({
            files: Object.fromEntries(manifest)
          }, null, 2)
        );
      });
    },
  };
}
