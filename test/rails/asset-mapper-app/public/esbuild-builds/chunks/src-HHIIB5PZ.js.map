{
  "version": 3,
  "sources": ["../../../node_modules/@rails/actioncable/src/adapters.js", "../../../node_modules/@rails/actioncable/src/logger.js", "../../../node_modules/@rails/actioncable/src/connection_monitor.js", "../../../node_modules/@rails/actioncable/src/internal.js", "../../../node_modules/@rails/actioncable/src/connection.js", "../../../node_modules/@rails/actioncable/src/subscription.js", "../../../node_modules/@rails/actioncable/src/subscription_guarantor.js", "../../../node_modules/@rails/actioncable/src/subscriptions.js", "../../../node_modules/@rails/actioncable/src/consumer.js", "../../../node_modules/@rails/actioncable/src/index.js"],
  "sourcesContent": ["export default {\n  logger: self.console,\n  WebSocket: self.WebSocket\n}\n", "import adapters from \"./adapters\"\n\n// The logger is disabled by default. You can enable it with:\n//\n//   ActionCable.logger.enabled = true\n//\n//   Example:\n//\n//   import * as ActionCable from '@rails/actioncable'\n//\n//   ActionCable.logger.enabled = true\n//   ActionCable.logger.log('Connection Established.')\n//\n\nexport default {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now())\n      adapters.logger.log(\"[ActionCable]\", ...messages)\n    }\n  },\n}\n", "import logger from \"./logger\"\n\n// Responsible for ensuring the cable connection is in good health by validating the heartbeat pings sent from the server, and attempting\n// revival reconnections if things go astray. Internal class, not intended for direct user manipulation.\n\nconst now = () => new Date().getTime()\n\nconst secondsSince = time => (now() - time) / 1000\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this)\n    this.connection = connection\n    this.reconnectAttempts = 0\n  }\n\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now()\n      delete this.stoppedAt\n      this.startPolling()\n      addEventListener(\"visibilitychange\", this.visibilityDidChange)\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`)\n    }\n  }\n\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now()\n      this.stopPolling()\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange)\n      logger.log(\"ConnectionMonitor stopped\")\n    }\n  }\n\n  isRunning() {\n    return this.startedAt && !this.stoppedAt\n  }\n\n  recordPing() {\n    this.pingedAt = now()\n  }\n\n  recordConnect() {\n    this.reconnectAttempts = 0\n    this.recordPing()\n    delete this.disconnectedAt\n    logger.log(\"ConnectionMonitor recorded connect\")\n  }\n\n  recordDisconnect() {\n    this.disconnectedAt = now()\n    logger.log(\"ConnectionMonitor recorded disconnect\")\n  }\n\n  // Private\n\n  startPolling() {\n    this.stopPolling()\n    this.poll()\n  }\n\n  stopPolling() {\n    clearTimeout(this.pollTimeout)\n  }\n\n  poll() {\n    this.pollTimeout = setTimeout(() => {\n      this.reconnectIfStale()\n      this.poll()\n    }\n    , this.getPollInterval())\n  }\n\n  getPollInterval() {\n    const { staleThreshold, reconnectionBackoffRate } = this.constructor\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10))\n    const jitterMax = this.reconnectAttempts === 0 ? 1.0 : reconnectionBackoffRate\n    const jitter = jitterMax * Math.random()\n    return staleThreshold * 1000 * backoff * (1 + jitter)\n  }\n\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`)\n      this.reconnectAttempts++\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`)\n      } else {\n        logger.log(\"ConnectionMonitor reopening\")\n        this.connection.reopen()\n      }\n    }\n  }\n\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt\n  }\n\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold\n  }\n\n  disconnectedRecently() {\n    return this.disconnectedAt && (secondsSince(this.disconnectedAt) < this.constructor.staleThreshold)\n  }\n\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout(() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`)\n          this.connection.reopen()\n        }\n      }\n      , 200)\n    }\n  }\n\n}\n\nConnectionMonitor.staleThreshold = 6 // Server::Connections::BEAT_INTERVAL * 2 (missed two pings)\nConnectionMonitor.reconnectionBackoffRate = 0.15\n\nexport default ConnectionMonitor\n", "export default {\n  \"message_types\": {\n    \"welcome\": \"welcome\",\n    \"disconnect\": \"disconnect\",\n    \"ping\": \"ping\",\n    \"confirmation\": \"confirm_subscription\",\n    \"rejection\": \"reject_subscription\"\n  },\n  \"disconnect_reasons\": {\n    \"unauthorized\": \"unauthorized\",\n    \"invalid_request\": \"invalid_request\",\n    \"server_restart\": \"server_restart\"\n  },\n  \"default_mount_path\": \"/cable\",\n  \"protocols\": [\n    \"actioncable-v1-json\",\n    \"actioncable-unsupported\"\n  ]\n}\n", "import adapters from \"./adapters\"\nimport ConnectionMonitor from \"./connection_monitor\"\nimport INTERNAL from \"./internal\"\nimport logger from \"./logger\"\n\n// Encapsulate the cable connection held by the consumer. This is an internal class not intended for direct user manipulation.\n\nconst {message_types, protocols} = INTERNAL\nconst supportedProtocols = protocols.slice(0, protocols.length - 1)\n\nconst indexOf = [].indexOf\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this)\n    this.consumer = consumer\n    this.subscriptions = this.consumer.subscriptions\n    this.monitor = new ConnectionMonitor(this)\n    this.disconnected = true\n  }\n\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data))\n      return true\n    } else {\n      return false\n    }\n  }\n\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`)\n      return false\n    } else {\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`)\n      if (this.webSocket) { this.uninstallEventHandlers() }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, protocols)\n      this.installEventHandlers()\n      this.monitor.start()\n      return true\n    }\n  }\n\n  close({allowReconnect} = {allowReconnect: true}) {\n    if (!allowReconnect) { this.monitor.stop() }\n    // Avoid closing websockets in a \"connecting\" state due to Safari 15.1+ bug. See: https://github.com/rails/rails/issues/43835#issuecomment-1002288478\n    if (this.isOpen()) {\n      return this.webSocket.close()\n    }\n  }\n\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`)\n    if (this.isActive()) {\n      try {\n        return this.close()\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error)\n      }\n      finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`)\n        setTimeout(this.open, this.constructor.reopenDelay)\n      }\n    } else {\n      return this.open()\n    }\n  }\n\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol\n    }\n  }\n\n  isOpen() {\n    return this.isState(\"open\")\n  }\n\n  isActive() {\n    return this.isState(\"open\", \"connecting\")\n  }\n\n  // Private\n\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0\n  }\n\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0\n  }\n\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase()\n        }\n      }\n    }\n    return null\n  }\n\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this)\n      this.webSocket[`on${eventName}`] = handler\n    }\n  }\n\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function() {}\n    }\n  }\n\n}\n\nConnection.reopenDelay = 500\n\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) { return }\n    const {identifier, message, reason, reconnect, type} = JSON.parse(event.data)\n    switch (type) {\n      case message_types.welcome:\n        this.monitor.recordConnect()\n        return this.subscriptions.reload()\n      case message_types.disconnect:\n        logger.log(`Disconnecting. Reason: ${reason}`)\n        return this.close({allowReconnect: reconnect})\n      case message_types.ping:\n        return this.monitor.recordPing()\n      case message_types.confirmation:\n        this.subscriptions.confirmSubscription(identifier)\n        return this.subscriptions.notify(identifier, \"connected\")\n      case message_types.rejection:\n        return this.subscriptions.reject(identifier)\n      default:\n        return this.subscriptions.notify(identifier, \"received\", message)\n    }\n  },\n\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`)\n    this.disconnected = false\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\")\n      return this.close({allowReconnect: false})\n    }\n  },\n\n  close(event) {\n    logger.log(\"WebSocket onclose event\")\n    if (this.disconnected) { return }\n    this.disconnected = true\n    this.monitor.recordDisconnect()\n    return this.subscriptions.notifyAll(\"disconnected\", {willAttemptReconnect: this.monitor.isRunning()})\n  },\n\n  error() {\n    logger.log(\"WebSocket onerror event\")\n  }\n}\n\nexport default Connection\n", "// A new subscription is created through the ActionCable.Subscriptions instance available on the consumer.\n// It provides a number of callbacks and a method for calling remote procedure calls on the corresponding\n// Channel instance on the server side.\n//\n// An example demonstrates the basic functionality:\n//\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\", {\n//     connected() {\n//       // Called once the subscription has been successfully completed\n//     },\n//\n//     disconnected({ willAttemptReconnect: boolean }) {\n//       // Called when the client has disconnected with the server.\n//       // The object will have an `willAttemptReconnect` property which\n//       // says whether the client has the intention of attempting\n//       // to reconnect.\n//     },\n//\n//     appear() {\n//       this.perform('appear', {appearing_on: this.appearingOn()})\n//     },\n//\n//     away() {\n//       this.perform('away')\n//     },\n//\n//     appearingOn() {\n//       $('main').data('appearing-on')\n//     }\n//   })\n//\n// The methods #appear and #away forward their intent to the remote AppearanceChannel instance on the server\n// by calling the `perform` method with the first parameter being the action (which maps to AppearanceChannel#appear/away).\n// The second parameter is a hash that'll get JSON encoded and made available on the server in the data parameter.\n//\n// This is how the server component would look:\n//\n//   class AppearanceChannel < ApplicationActionCable::Channel\n//     def subscribed\n//       current_user.appear\n//     end\n//\n//     def unsubscribed\n//       current_user.disappear\n//     end\n//\n//     def appear(data)\n//       current_user.appear on: data['appearing_on']\n//     end\n//\n//     def away\n//       current_user.away\n//     end\n//   end\n//\n// The \"AppearanceChannel\" name is automatically mapped between the client-side subscription creation and the server-side Ruby class name.\n// The AppearanceChannel#appear/away public methods are exposed automatically to client-side invocation through the perform method.\n\nconst extend = function(object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key]\n      object[key] = value\n    }\n  }\n  return object\n}\n\nexport default class Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer\n    this.identifier = JSON.stringify(params)\n    extend(this, mixin)\n  }\n\n  // Perform a channel action with the optional data passed as an attribute\n  perform(action, data = {}) {\n    data.action = action\n    return this.send(data)\n  }\n\n  send(data) {\n    return this.consumer.send({command: \"message\", identifier: this.identifier, data: JSON.stringify(data)})\n  }\n\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this)\n  }\n}\n", "import logger from \"./logger\"\n\n// Responsible for ensuring channel subscribe command is confirmed, retrying until confirmation is received.\n// Internal class, not intended for direct user manipulation.\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions\n    this.pendingSubscriptions = []\n  }\n\n  guarantee(subscription) {\n    if(this.pendingSubscriptions.indexOf(subscription) == -1){ \n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`)\n      this.pendingSubscriptions.push(subscription) \n    }\n    else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`)\n    }\n    this.startGuaranteeing()\n  }\n\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`)\n    this.pendingSubscriptions = (this.pendingSubscriptions.filter((s) => s !== subscription))\n  }\n\n  startGuaranteeing() {\n    this.stopGuaranteeing()\n    this.retrySubscribing()\n  }\n  \n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout)\n  }\n\n  retrySubscribing() {\n    this.retryTimeout = setTimeout(() => {\n      if (this.subscriptions && typeof(this.subscriptions.subscribe) === \"function\") {\n        this.pendingSubscriptions.map((subscription) => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`)\n          this.subscriptions.subscribe(subscription)\n        })\n      }\n    }\n    , 500)\n  }\n}\n\nexport default SubscriptionGuarantor", "import Subscription from \"./subscription\"\nimport SubscriptionGuarantor from \"./subscription_guarantor\"\nimport logger from \"./logger\"\n\n// Collection class for creating (and internally managing) channel subscriptions.\n// The only method intended to be triggered by the user is ActionCable.Subscriptions#create,\n// and it should be called through the consumer like so:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n\nexport default class Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer\n    this.guarantor = new SubscriptionGuarantor(this)\n    this.subscriptions = []\n  }\n\n  create(channelName, mixin) {\n    const channel = channelName\n    const params = typeof channel === \"object\" ? channel : {channel}\n    const subscription = new Subscription(this.consumer, params, mixin)\n    return this.add(subscription)\n  }\n\n  // Private\n\n  add(subscription) {\n    this.subscriptions.push(subscription)\n    this.consumer.ensureActiveConnection()\n    this.notify(subscription, \"initialized\")\n    this.subscribe(subscription)\n    return subscription\n  }\n\n  remove(subscription) {\n    this.forget(subscription)\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\")\n    }\n    return subscription\n  }\n\n  reject(identifier) {\n    return this.findAll(identifier).map((subscription) => {\n      this.forget(subscription)\n      this.notify(subscription, \"rejected\")\n      return subscription\n    })\n  }\n\n  forget(subscription) {\n    this.guarantor.forget(subscription)\n    this.subscriptions = (this.subscriptions.filter((s) => s !== subscription))\n    return subscription\n  }\n\n  findAll(identifier) {\n    return this.subscriptions.filter((s) => s.identifier === identifier)\n  }\n\n  reload() {\n    return this.subscriptions.map((subscription) =>\n      this.subscribe(subscription))\n  }\n\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map((subscription) =>\n      this.notify(subscription, callbackName, ...args))\n  }\n\n  notify(subscription, callbackName, ...args) {\n    let subscriptions\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription)\n    } else {\n      subscriptions = [subscription]\n    }\n\n    return subscriptions.map((subscription) =>\n      (typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined))\n  }\n\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription)\n    }\n  }\n\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`)\n    this.findAll(identifier).map((subscription) =>\n      this.guarantor.forget(subscription))\n  }\n\n  sendCommand(subscription, command) {\n    const {identifier} = subscription\n    return this.consumer.send({command, identifier})\n  }\n}\n", "import Connection from \"./connection\"\nimport Subscriptions from \"./subscriptions\"\n\n// The ActionCable.Consumer establishes the connection to a server-side Ruby Connection object. Once established,\n// the ActionCable.ConnectionMonitor will ensure that its properly maintained through heartbeats and checking for stale updates.\n// The Consumer instance is also the gateway to establishing subscriptions to desired channels through the #createSubscription\n// method.\n//\n// The following example shows how this can be set up:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n//\n// When a consumer is created, it automatically connects with the server.\n//\n// To disconnect from the server, call\n//\n//   App.cable.disconnect()\n//\n// and to restart the connection:\n//\n//   App.cable.connect()\n//\n// Any channel subscriptions which existed prior to disconnecting will\n// automatically resubscribe.\n\nexport default class Consumer {\n  constructor(url) {\n    this._url = url\n    this.subscriptions = new Subscriptions(this)\n    this.connection = new Connection(this)\n  }\n\n  get url() {\n    return createWebSocketURL(this._url)\n  }\n\n  send(data) {\n    return this.connection.send(data)\n  }\n\n  connect() {\n    return this.connection.open()\n  }\n\n  disconnect() {\n    return this.connection.close({allowReconnect: false})\n  }\n\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open()\n    }\n  }\n}\n\nexport function createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url()\n  }\n\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\")\n    a.href = url\n    // Fix populating Location properties in IE. Otherwise, protocol will be blank.\n    a.href = a.href\n    a.protocol = a.protocol.replace(\"http\", \"ws\")\n    return a.href\n  } else {\n    return url\n  }\n}\n", "import Connection from \"./connection\"\nimport ConnectionMonitor from \"./connection_monitor\"\nimport Consumer, { createWebSocketURL } from \"./consumer\"\nimport INTERNAL from \"./internal\"\nimport Subscription from \"./subscription\"\nimport Subscriptions from \"./subscriptions\"\nimport SubscriptionGuarantor from \"./subscription_guarantor\"\nimport adapters from \"./adapters\"\nimport logger from \"./logger\"\n\nexport {\n  Connection,\n  ConnectionMonitor,\n  Consumer,\n  INTERNAL,\n  Subscription,\n  Subscriptions,\n  SubscriptionGuarantor,\n  adapters,\n  createWebSocketURL,\n  logger,\n}\n\nexport function createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url)\n}\n\nexport function getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`)\n  if (element) {\n    return element.getAttribute(\"content\")\n  }\n}\n"],
  "mappings": ";AAAA,IAAO,mBAAQ;AAAA,EACb,QAAQ,KAAK;AAAA,EACb,WAAW,KAAK;AAClB;;;ACWA,IAAO,iBAAQ;AAAA,EACb,OAAO,UAAU;AACf,QAAI,KAAK,SAAS;AAChB,eAAS,KAAK,KAAK,IAAI,CAAC;AACxB,uBAAS,OAAO,IAAI,iBAAiB,GAAG,QAAQ;AAAA,IAClD;AAAA,EACF;AACF;;;AChBA,IAAM,MAAM,MAAM,IAAI,KAAK,EAAE,QAAQ;AAErC,IAAM,eAAe,WAAS,IAAI,IAAI,QAAQ;AAE9C,IAAM,oBAAN,MAAwB;AAAA,EACtB,YAAY,YAAY;AACtB,SAAK,sBAAsB,KAAK,oBAAoB,KAAK,IAAI;AAC7D,SAAK,aAAa;AAClB,SAAK,oBAAoB;AAAA,EAC3B;AAAA,EAEA,QAAQ;AACN,QAAI,CAAC,KAAK,UAAU,GAAG;AACrB,WAAK,YAAY,IAAI;AACrB,aAAO,KAAK;AACZ,WAAK,aAAa;AAClB,uBAAiB,oBAAoB,KAAK,mBAAmB;AAC7D,qBAAO,IAAI,gDAAgD,KAAK,YAAY,kBAAkB;AAAA,IAChG;AAAA,EACF;AAAA,EAEA,OAAO;AACL,QAAI,KAAK,UAAU,GAAG;AACpB,WAAK,YAAY,IAAI;AACrB,WAAK,YAAY;AACjB,0BAAoB,oBAAoB,KAAK,mBAAmB;AAChE,qBAAO,IAAI,2BAA2B;AAAA,IACxC;AAAA,EACF;AAAA,EAEA,YAAY;AACV,WAAO,KAAK,aAAa,CAAC,KAAK;AAAA,EACjC;AAAA,EAEA,aAAa;AACX,SAAK,WAAW,IAAI;AAAA,EACtB;AAAA,EAEA,gBAAgB;AACd,SAAK,oBAAoB;AACzB,SAAK,WAAW;AAChB,WAAO,KAAK;AACZ,mBAAO,IAAI,oCAAoC;AAAA,EACjD;AAAA,EAEA,mBAAmB;AACjB,SAAK,iBAAiB,IAAI;AAC1B,mBAAO,IAAI,uCAAuC;AAAA,EACpD;AAAA,EAIA,eAAe;AACb,SAAK,YAAY;AACjB,SAAK,KAAK;AAAA,EACZ;AAAA,EAEA,cAAc;AACZ,iBAAa,KAAK,WAAW;AAAA,EAC/B;AAAA,EAEA,OAAO;AACL,SAAK,cAAc;AAAA,MAAW,MAAM;AAClC,aAAK,iBAAiB;AACtB,aAAK,KAAK;AAAA,MACZ;AAAA,MACE,KAAK,gBAAgB;AAAA,IAAC;AAAA,EAC1B;AAAA,EAEA,kBAAkB;AAChB,UAAM,EAAE,gBAAgB,wBAAwB,IAAI,KAAK;AACzD,UAAM,UAAU,KAAK,IAAI,IAAI,yBAAyB,KAAK,IAAI,KAAK,mBAAmB,EAAE,CAAC;AAC1F,UAAM,YAAY,KAAK,sBAAsB,IAAI,IAAM;AACvD,UAAM,SAAS,YAAY,KAAK,OAAO;AACvC,WAAO,iBAAiB,MAAO,WAAW,IAAI;AAAA,EAChD;AAAA,EAEA,mBAAmB;AACjB,QAAI,KAAK,kBAAkB,GAAG;AAC5B,qBAAO,IAAI,oEAAoE,KAAK,mCAAmC,aAAa,KAAK,WAAW,0BAA0B,KAAK,YAAY,kBAAkB;AACjN,WAAK;AACL,UAAI,KAAK,qBAAqB,GAAG;AAC/B,uBAAO,IAAI,+EAA+E,aAAa,KAAK,cAAc,KAAK;AAAA,MACjI,OAAO;AACL,uBAAO,IAAI,6BAA6B;AACxC,aAAK,WAAW,OAAO;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA,EAEA,IAAI,cAAc;AAChB,WAAO,KAAK,WAAW,KAAK,WAAW,KAAK;AAAA,EAC9C;AAAA,EAEA,oBAAoB;AAClB,WAAO,aAAa,KAAK,WAAW,IAAI,KAAK,YAAY;AAAA,EAC3D;AAAA,EAEA,uBAAuB;AACrB,WAAO,KAAK,kBAAmB,aAAa,KAAK,cAAc,IAAI,KAAK,YAAY;AAAA,EACtF;AAAA,EAEA,sBAAsB;AACpB,QAAI,SAAS,oBAAoB,WAAW;AAC1C;AAAA,QAAW,MAAM;AACf,cAAI,KAAK,kBAAkB,KAAK,CAAC,KAAK,WAAW,OAAO,GAAG;AACzD,2BAAO,IAAI,uFAAuF,SAAS,iBAAiB;AAC5H,iBAAK,WAAW,OAAO;AAAA,UACzB;AAAA,QACF;AAAA,QACE;AAAA,MAAG;AAAA,IACP;AAAA,EACF;AAEF;AAEA,kBAAkB,iBAAiB;AACnC,kBAAkB,0BAA0B;AAE5C,IAAO,6BAAQ;;;AC5Hf,IAAO,mBAAQ;AAAA,EACb,iBAAiB;AAAA,IACf,WAAW;AAAA,IACX,cAAc;AAAA,IACd,QAAQ;AAAA,IACR,gBAAgB;AAAA,IAChB,aAAa;AAAA,EACf;AAAA,EACA,sBAAsB;AAAA,IACpB,gBAAgB;AAAA,IAChB,mBAAmB;AAAA,IACnB,kBAAkB;AAAA,EACpB;AAAA,EACA,sBAAsB;AAAA,EACtB,aAAa;AAAA,IACX;AAAA,IACA;AAAA,EACF;AACF;;;ACXA,IAAM,EAAC,eAAe,UAAS,IAAI;AACnC,IAAM,qBAAqB,UAAU,MAAM,GAAG,UAAU,SAAS,CAAC;AAElE,IAAM,UAAU,CAAC,EAAE;AAEnB,IAAM,aAAN,MAAiB;AAAA,EACf,YAAY,UAAU;AACpB,SAAK,OAAO,KAAK,KAAK,KAAK,IAAI;AAC/B,SAAK,WAAW;AAChB,SAAK,gBAAgB,KAAK,SAAS;AACnC,SAAK,UAAU,IAAI,2BAAkB,IAAI;AACzC,SAAK,eAAe;AAAA,EACtB;AAAA,EAEA,KAAK,MAAM;AACT,QAAI,KAAK,OAAO,GAAG;AACjB,WAAK,UAAU,KAAK,KAAK,UAAU,IAAI,CAAC;AACxC,aAAO;AAAA,IACT,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,OAAO;AACL,QAAI,KAAK,SAAS,GAAG;AACnB,qBAAO,IAAI,uDAAuD,KAAK,SAAS,GAAG;AACnF,aAAO;AAAA,IACT,OAAO;AACL,qBAAO,IAAI,uCAAuC,KAAK,SAAS,oBAAoB,WAAW;AAC/F,UAAI,KAAK,WAAW;AAAE,aAAK,uBAAuB;AAAA,MAAE;AACpD,WAAK,YAAY,IAAI,iBAAS,UAAU,KAAK,SAAS,KAAK,SAAS;AACpE,WAAK,qBAAqB;AAC1B,WAAK,QAAQ,MAAM;AACnB,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,MAAM,EAAC,eAAc,IAAI,EAAC,gBAAgB,KAAI,GAAG;AAC/C,QAAI,CAAC,gBAAgB;AAAE,WAAK,QAAQ,KAAK;AAAA,IAAE;AAE3C,QAAI,KAAK,OAAO,GAAG;AACjB,aAAO,KAAK,UAAU,MAAM;AAAA,IAC9B;AAAA,EACF;AAAA,EAEA,SAAS;AACP,mBAAO,IAAI,yCAAyC,KAAK,SAAS,GAAG;AACrE,QAAI,KAAK,SAAS,GAAG;AACnB,UAAI;AACF,eAAO,KAAK,MAAM;AAAA,MACpB,SAAS,OAAP;AACA,uBAAO,IAAI,8BAA8B,KAAK;AAAA,MAChD,UACA;AACE,uBAAO,IAAI,0BAA0B,KAAK,YAAY,eAAe;AACrE,mBAAW,KAAK,MAAM,KAAK,YAAY,WAAW;AAAA,MACpD;AAAA,IACF,OAAO;AACL,aAAO,KAAK,KAAK;AAAA,IACnB;AAAA,EACF;AAAA,EAEA,cAAc;AACZ,QAAI,KAAK,WAAW;AAClB,aAAO,KAAK,UAAU;AAAA,IACxB;AAAA,EACF;AAAA,EAEA,SAAS;AACP,WAAO,KAAK,QAAQ,MAAM;AAAA,EAC5B;AAAA,EAEA,WAAW;AACT,WAAO,KAAK,QAAQ,QAAQ,YAAY;AAAA,EAC1C;AAAA,EAIA,sBAAsB;AACpB,WAAO,QAAQ,KAAK,oBAAoB,KAAK,YAAY,CAAC,KAAK;AAAA,EACjE;AAAA,EAEA,WAAW,QAAQ;AACjB,WAAO,QAAQ,KAAK,QAAQ,KAAK,SAAS,CAAC,KAAK;AAAA,EAClD;AAAA,EAEA,WAAW;AACT,QAAI,KAAK,WAAW;AAClB,eAAS,SAAS,iBAAS,WAAW;AACpC,YAAI,iBAAS,UAAU,WAAW,KAAK,UAAU,YAAY;AAC3D,iBAAO,MAAM,YAAY;AAAA,QAC3B;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,uBAAuB;AACrB,aAAS,aAAa,KAAK,QAAQ;AACjC,YAAM,UAAU,KAAK,OAAO,WAAW,KAAK,IAAI;AAChD,WAAK,UAAU,KAAK,eAAe;AAAA,IACrC;AAAA,EACF;AAAA,EAEA,yBAAyB;AACvB,aAAS,aAAa,KAAK,QAAQ;AACjC,WAAK,UAAU,KAAK,eAAe,WAAW;AAAA,MAAC;AAAA,IACjD;AAAA,EACF;AAEF;AAEA,WAAW,cAAc;AAEzB,WAAW,UAAU,SAAS;AAAA,EAC5B,QAAQ,OAAO;AACb,QAAI,CAAC,KAAK,oBAAoB,GAAG;AAAE;AAAA,IAAO;AAC1C,UAAM,EAAC,YAAY,SAAS,QAAQ,WAAW,KAAI,IAAI,KAAK,MAAM,MAAM,IAAI;AAC5E,YAAQ,MAAM;AAAA,MACZ,KAAK,cAAc;AACjB,aAAK,QAAQ,cAAc;AAC3B,eAAO,KAAK,cAAc,OAAO;AAAA,MACnC,KAAK,cAAc;AACjB,uBAAO,IAAI,0BAA0B,QAAQ;AAC7C,eAAO,KAAK,MAAM,EAAC,gBAAgB,UAAS,CAAC;AAAA,MAC/C,KAAK,cAAc;AACjB,eAAO,KAAK,QAAQ,WAAW;AAAA,MACjC,KAAK,cAAc;AACjB,aAAK,cAAc,oBAAoB,UAAU;AACjD,eAAO,KAAK,cAAc,OAAO,YAAY,WAAW;AAAA,MAC1D,KAAK,cAAc;AACjB,eAAO,KAAK,cAAc,OAAO,UAAU;AAAA,MAC7C;AACE,eAAO,KAAK,cAAc,OAAO,YAAY,YAAY,OAAO;AAAA,IACpE;AAAA,EACF;AAAA,EAEA,OAAO;AACL,mBAAO,IAAI,kCAAkC,KAAK,YAAY,gBAAgB;AAC9E,SAAK,eAAe;AACpB,QAAI,CAAC,KAAK,oBAAoB,GAAG;AAC/B,qBAAO,IAAI,8DAA8D;AACzE,aAAO,KAAK,MAAM,EAAC,gBAAgB,MAAK,CAAC;AAAA,IAC3C;AAAA,EACF;AAAA,EAEA,MAAM,OAAO;AACX,mBAAO,IAAI,yBAAyB;AACpC,QAAI,KAAK,cAAc;AAAE;AAAA,IAAO;AAChC,SAAK,eAAe;AACpB,SAAK,QAAQ,iBAAiB;AAC9B,WAAO,KAAK,cAAc,UAAU,gBAAgB,EAAC,sBAAsB,KAAK,QAAQ,UAAU,EAAC,CAAC;AAAA,EACtG;AAAA,EAEA,QAAQ;AACN,mBAAO,IAAI,yBAAyB;AAAA,EACtC;AACF;AAEA,IAAO,qBAAQ;;;AC5Gf,IAAM,SAAS,SAAS,QAAQ,YAAY;AAC1C,MAAI,cAAc,MAAM;AACtB,aAAS,OAAO,YAAY;AAC1B,YAAM,QAAQ,WAAW;AACzB,aAAO,OAAO;AAAA,IAChB;AAAA,EACF;AACA,SAAO;AACT;AAEA,IAAqB,eAArB,MAAkC;AAAA,EAChC,YAAY,UAAU,SAAS,CAAC,GAAG,OAAO;AACxC,SAAK,WAAW;AAChB,SAAK,aAAa,KAAK,UAAU,MAAM;AACvC,WAAO,MAAM,KAAK;AAAA,EACpB;AAAA,EAGA,QAAQ,QAAQ,OAAO,CAAC,GAAG;AACzB,SAAK,SAAS;AACd,WAAO,KAAK,KAAK,IAAI;AAAA,EACvB;AAAA,EAEA,KAAK,MAAM;AACT,WAAO,KAAK,SAAS,KAAK,EAAC,SAAS,WAAW,YAAY,KAAK,YAAY,MAAM,KAAK,UAAU,IAAI,EAAC,CAAC;AAAA,EACzG;AAAA,EAEA,cAAc;AACZ,WAAO,KAAK,SAAS,cAAc,OAAO,IAAI;AAAA,EAChD;AACF;;;ACnFA,IAAM,wBAAN,MAA4B;AAAA,EAC1B,YAAY,eAAe;AACzB,SAAK,gBAAgB;AACrB,SAAK,uBAAuB,CAAC;AAAA,EAC/B;AAAA,EAEA,UAAU,cAAc;AACtB,QAAG,KAAK,qBAAqB,QAAQ,YAAY,KAAK,IAAG;AACvD,qBAAO,IAAI,sCAAsC,aAAa,YAAY;AAC1E,WAAK,qBAAqB,KAAK,YAAY;AAAA,IAC7C,OACK;AACH,qBAAO,IAAI,8CAA8C,aAAa,YAAY;AAAA,IACpF;AACA,SAAK,kBAAkB;AAAA,EACzB;AAAA,EAEA,OAAO,cAAc;AACnB,mBAAO,IAAI,oCAAoC,aAAa,YAAY;AACxE,SAAK,uBAAwB,KAAK,qBAAqB,OAAO,CAAC,MAAM,MAAM,YAAY;AAAA,EACzF;AAAA,EAEA,oBAAoB;AAClB,SAAK,iBAAiB;AACtB,SAAK,iBAAiB;AAAA,EACxB;AAAA,EAEA,mBAAmB;AACjB,iBAAa,KAAK,YAAY;AAAA,EAChC;AAAA,EAEA,mBAAmB;AACjB,SAAK,eAAe;AAAA,MAAW,MAAM;AACnC,YAAI,KAAK,iBAAiB,OAAO,KAAK,cAAc,cAAe,YAAY;AAC7E,eAAK,qBAAqB,IAAI,CAAC,iBAAiB;AAC9C,2BAAO,IAAI,uCAAuC,aAAa,YAAY;AAC3E,iBAAK,cAAc,UAAU,YAAY;AAAA,UAC3C,CAAC;AAAA,QACH;AAAA,MACF;AAAA,MACE;AAAA,IAAG;AAAA,EACP;AACF;AAEA,IAAO,iCAAQ;;;ACnCf,IAAqB,gBAArB,MAAmC;AAAA,EACjC,YAAY,UAAU;AACpB,SAAK,WAAW;AAChB,SAAK,YAAY,IAAI,+BAAsB,IAAI;AAC/C,SAAK,gBAAgB,CAAC;AAAA,EACxB;AAAA,EAEA,OAAO,aAAa,OAAO;AACzB,UAAM,UAAU;AAChB,UAAM,SAAS,OAAO,YAAY,WAAW,UAAU,EAAC,QAAO;AAC/D,UAAM,eAAe,IAAI,aAAa,KAAK,UAAU,QAAQ,KAAK;AAClE,WAAO,KAAK,IAAI,YAAY;AAAA,EAC9B;AAAA,EAIA,IAAI,cAAc;AAChB,SAAK,cAAc,KAAK,YAAY;AACpC,SAAK,SAAS,uBAAuB;AACrC,SAAK,OAAO,cAAc,aAAa;AACvC,SAAK,UAAU,YAAY;AAC3B,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,cAAc;AACnB,SAAK,OAAO,YAAY;AACxB,QAAI,CAAC,KAAK,QAAQ,aAAa,UAAU,EAAE,QAAQ;AACjD,WAAK,YAAY,cAAc,aAAa;AAAA,IAC9C;AACA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,YAAY;AACjB,WAAO,KAAK,QAAQ,UAAU,EAAE,IAAI,CAAC,iBAAiB;AACpD,WAAK,OAAO,YAAY;AACxB,WAAK,OAAO,cAAc,UAAU;AACpC,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA,EAEA,OAAO,cAAc;AACnB,SAAK,UAAU,OAAO,YAAY;AAClC,SAAK,gBAAiB,KAAK,cAAc,OAAO,CAAC,MAAM,MAAM,YAAY;AACzE,WAAO;AAAA,EACT;AAAA,EAEA,QAAQ,YAAY;AAClB,WAAO,KAAK,cAAc,OAAO,CAAC,MAAM,EAAE,eAAe,UAAU;AAAA,EACrE;AAAA,EAEA,SAAS;AACP,WAAO,KAAK,cAAc,IAAI,CAAC,iBAC7B,KAAK,UAAU,YAAY,CAAC;AAAA,EAChC;AAAA,EAEA,UAAU,iBAAiB,MAAM;AAC/B,WAAO,KAAK,cAAc,IAAI,CAAC,iBAC7B,KAAK,OAAO,cAAc,cAAc,GAAG,IAAI,CAAC;AAAA,EACpD;AAAA,EAEA,OAAO,cAAc,iBAAiB,MAAM;AAC1C,QAAI;AACJ,QAAI,OAAO,iBAAiB,UAAU;AACpC,sBAAgB,KAAK,QAAQ,YAAY;AAAA,IAC3C,OAAO;AACL,sBAAgB,CAAC,YAAY;AAAA,IAC/B;AAEA,WAAO,cAAc,IAAI,CAACA,kBACvB,OAAOA,cAAa,kBAAkB,aAAaA,cAAa,cAAc,GAAG,IAAI,IAAI,MAAU;AAAA,EACxG;AAAA,EAEA,UAAU,cAAc;AACtB,QAAI,KAAK,YAAY,cAAc,WAAW,GAAG;AAC/C,WAAK,UAAU,UAAU,YAAY;AAAA,IACvC;AAAA,EACF;AAAA,EAEA,oBAAoB,YAAY;AAC9B,mBAAO,IAAI,0BAA0B,YAAY;AACjD,SAAK,QAAQ,UAAU,EAAE,IAAI,CAAC,iBAC5B,KAAK,UAAU,OAAO,YAAY,CAAC;AAAA,EACvC;AAAA,EAEA,YAAY,cAAc,SAAS;AACjC,UAAM,EAAC,WAAU,IAAI;AACrB,WAAO,KAAK,SAAS,KAAK,EAAC,SAAS,WAAU,CAAC;AAAA,EACjD;AACF;;;ACzEA,IAAqB,WAArB,MAA8B;AAAA,EAC5B,YAAY,KAAK;AACf,SAAK,OAAO;AACZ,SAAK,gBAAgB,IAAI,cAAc,IAAI;AAC3C,SAAK,aAAa,IAAI,mBAAW,IAAI;AAAA,EACvC;AAAA,EAEA,IAAI,MAAM;AACR,WAAO,mBAAmB,KAAK,IAAI;AAAA,EACrC;AAAA,EAEA,KAAK,MAAM;AACT,WAAO,KAAK,WAAW,KAAK,IAAI;AAAA,EAClC;AAAA,EAEA,UAAU;AACR,WAAO,KAAK,WAAW,KAAK;AAAA,EAC9B;AAAA,EAEA,aAAa;AACX,WAAO,KAAK,WAAW,MAAM,EAAC,gBAAgB,MAAK,CAAC;AAAA,EACtD;AAAA,EAEA,yBAAyB;AACvB,QAAI,CAAC,KAAK,WAAW,SAAS,GAAG;AAC/B,aAAO,KAAK,WAAW,KAAK;AAAA,IAC9B;AAAA,EACF;AACF;AAEO,SAAS,mBAAmB,KAAK;AACtC,MAAI,OAAO,QAAQ,YAAY;AAC7B,UAAM,IAAI;AAAA,EACZ;AAEA,MAAI,OAAO,CAAC,UAAU,KAAK,GAAG,GAAG;AAC/B,UAAM,IAAI,SAAS,cAAc,GAAG;AACpC,MAAE,OAAO;AAET,MAAE,OAAO,EAAE;AACX,MAAE,WAAW,EAAE,SAAS,QAAQ,QAAQ,IAAI;AAC5C,WAAO,EAAE;AAAA,EACX,OAAO;AACL,WAAO;AAAA,EACT;AACF;;;ACnDO,SAAS,eAAe,MAAM,UAAU,KAAK,KAAK,iBAAS,oBAAoB;AACpF,SAAO,IAAI,SAAS,GAAG;AACzB;AAEO,SAAS,UAAU,MAAM;AAC9B,QAAM,UAAU,SAAS,KAAK,cAAc,2BAA2B,QAAQ;AAC/E,MAAI,SAAS;AACX,WAAO,QAAQ,aAAa,SAAS;AAAA,EACvC;AACF;",
  "names": ["subscription"]
}
